---
title: "Bé Thỏ (Phần 2) - Những cái bẫy chết người"
title_vi: "Bé Thỏ (Phần 2) - Những cái bẫy chết người"
title_en: "Little Rabbit (Part 2) - The Deadly Traps"
excerpt_vi: "Channel leak, reply queue explosion, và những bài học đắt giá khi làm việc với RabbitMQ. Singleton pattern không chỉ là lý thuyết trong sách."
excerpt_en: "Channel leak, reply queue explosion, and expensive lessons when working with RabbitMQ. Singleton pattern is not just theory from textbooks."
date: 2025-01-18
tags:
  - RabbitMQ
  - Architecture
  - Message Queue
  - Debugging
  - Series Bé Thỏ
thumbnail: https://images.unsplash.com/photo-1578662996442-48f60103fc96?w=800
---

# Bé Thỏ (Phần 2) - Những cái bẫy chết người

## Mọi thứ đang chạy ngon lành...

Sau khi migrate từ HTTP sang RabbitMQ RPC ([Phần 1](/vi/blog/be-tho-part-1)), team tôi tưởng đã nắm vững bé Thỏ.

Load balancing tự nhiên. Scale dễ dàng. Message không mất.

Mọi thứ chạy ngon lành trong môi trường dev. Chạy ngon lành trong UAT. Thậm chí chạy ngon lành trong production...

...cho đến khi không còn ngon lành nữa.

![Trap](https://images.unsplash.com/photo-1578662996442-48f60103fc96?w=800)

## Bẫy số 1: Channel Leak

### Triệu chứng

Một ngày đẹp trời, RabbitMQ bắt đầu từ chối connection mới. Log hiện lên dòng chữ đáng sợ:

```
AMQP operation channel.open failed due to maximum channels limit
```

Nhìn vào dashboard, số lượng channels đang ở mức... **65,535** - đúng bằng giới hạn mặc định của RabbitMQ.

### Hiểu về Connection và Channel

Để hiểu bug này, cần hiểu cách RabbitMQ hoạt động:

**Connection** là một kết nối TCP thực sự giữa application và RabbitMQ server. Tạo connection tốn kém (TCP handshake, authentication...).

**Channel** là một "kênh ảo" bên trong connection. Một connection có thể có nhiều channels. Tạo channel nhẹ hơn nhiều so với connection.

Hãy tưởng tượng **connection** như một đường cao tốc, và **channels** như các làn xe trên đường đó.

![Highway Lanes](https://images.unsplash.com/photo-1515162816999-a0c47dc192f7?w=800)

### Thủ phạm

Developer viết code như này:

```java
// Mỗi request tạo một channel mới
public void sendMessage(String message) {
    Channel channel = connection.createChannel();
    channel.basicPublish("exchange", "routing.key",
        null, message.getBytes());
    // Xử lý xong... quên close channel!
}
```

Mỗi request tạo một channel mới. **Nhưng không ai close channel.**

1 triệu requests = 1 triệu channels mở = RabbitMQ chết.

### Giải pháp: Singleton Channel

Thay vì tạo channel mới mỗi request, chúng tôi dùng **Singleton pattern**:

```java
public class RabbitMQProducer {
    private static RabbitMQProducer instance;
    private Connection connection;
    private Channel channel;  // Singleton channel

    private RabbitMQProducer() {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("localhost");
        this.connection = factory.newConnection();
        this.channel = connection.createChannel();
    }

    public static synchronized RabbitMQProducer getInstance() {
        if (instance == null) {
            instance = new RabbitMQProducer();
        }
        return instance;
    }

    public void sendMessage(String message) {
        // Reuse channel thay vì tạo mới
        channel.basicPublish("exchange", "routing.key",
            null, message.getBytes());
    }
}
```

**Một connection, một channel, dùng chung cho tất cả requests.**

### Lưu ý về Thread Safety

Channel trong RabbitMQ **không thread-safe**. Nếu bạn có multiple threads cùng dùng một channel, cần synchronize:

```java
public synchronized void sendMessage(String message) {
    channel.basicPublish("exchange", "routing.key",
        null, message.getBytes());
}
```

Hoặc dùng **channel pool** - một số channels được tạo sẵn, threads mượn và trả lại.

---

## Bẫy số 2: Reply Queue Explosion

Đây là bẫy kinh hoàng hơn nhiều.

### RPC Pattern - Cách hoạt động

Nhớ lại cách RPC pattern hoạt động:

**Request:**
1. Producer tạo một **reply queue** riêng để nhận response
2. Gửi message với `replyTo = <tên queue reply>`
3. Chờ response trên queue đó

**Response:**
1. Consumer nhận message, xử lý
2. Gửi response vào queue được chỉ định trong `replyTo`
3. Producer nhận được response

### Vấn đề

Developer viết code như này:

```java
public String callRPC(String request) {
    // Tạo một queue reply MỚI cho mỗi request
    String replyQueueName = channel.queueDeclare().getQueue();

    // Gửi request với replyTo
    AMQP.BasicProperties props = new AMQP.BasicProperties.Builder()
        .replyTo(replyQueueName)
        .correlationId(UUID.randomUUID().toString())
        .build();

    channel.basicPublish("", "rpc_queue", props, request.getBytes());

    // Chờ response...
    // Xong việc... QUÊN XÓA QUEUE REPLY!
}
```

Mỗi RPC request tạo một queue reply mới. **Không ai xóa queue sau khi dùng xong.**

- 1.000 requests = 1.000 queues
- 100.000 requests = 100.000 queues
- 1.000.000 requests = 1.000.000 queues

![Explosion](https://images.unsplash.com/photo-1635070041078-e363dbe005cb?w=800)

### Hậu quả

RabbitMQ bắt đầu:
- **Memory tăng vọt** - mỗi queue tiêu tốn memory
- **Erlang processes tăng** - mỗi queue là một Erlang process
- **Management UI chậm** - list 1 triệu queues là ác mộng
- **Cuối cùng: crash**

### Giải pháp 1: Direct Reply-to

RabbitMQ có một feature đặc biệt gọi là **Direct Reply-to**.

Thay vì tạo queue riêng, bạn dùng một pseudo-queue có tên `amq.rabbitmq.reply-to`:

```java
public String callRPC(String request) {
    // Dùng Direct Reply-to thay vì tạo queue mới
    String replyTo = "amq.rabbitmq.reply-to";

    AMQP.BasicProperties props = new AMQP.BasicProperties.Builder()
        .replyTo(replyTo)
        .correlationId(UUID.randomUUID().toString())
        .build();

    channel.basicPublish("", "rpc_queue", props, request.getBytes());

    // RabbitMQ sẽ route response trực tiếp về consumer
    // KHÔNG tạo queue thực sự!
}
```

**Ưu điểm:**
- Không tạo queue thực sự
- Response được route trực tiếp đến consumer
- Không cần cleanup

**Nhược điểm:**
- Chỉ hoạt động trên cùng channel
- Không có message persistence (nếu consumer chết, response mất)

### Giải pháp 2: Singleton Reply Queue

Nếu cần persistence, dùng **một reply queue duy nhất** cho producer:

```java
public class RPCClient {
    private static RPCClient instance;
    private Channel channel;
    private String replyQueueName;  // Singleton reply queue
    private Map<String, CompletableFuture<String>> pendingRequests;

    private RPCClient() {
        // Tạo MỘT reply queue duy nhất
        this.replyQueueName = channel.queueDeclare().getQueue();
        this.pendingRequests = new ConcurrentHashMap<>();

        // Consumer cho reply queue
        channel.basicConsume(replyQueueName, true, (consumerTag, delivery) -> {
            String correlationId = delivery.getProperties().getCorrelationId();
            CompletableFuture<String> future = pendingRequests.remove(correlationId);
            if (future != null) {
                future.complete(new String(delivery.getBody()));
            }
        }, consumerTag -> {});
    }

    public String callRPC(String request) {
        String correlationId = UUID.randomUUID().toString();
        CompletableFuture<String> future = new CompletableFuture<>();
        pendingRequests.put(correlationId, future);

        AMQP.BasicProperties props = new AMQP.BasicProperties.Builder()
            .replyTo(replyQueueName)  // LUÔN dùng queue này
            .correlationId(correlationId)
            .build();

        channel.basicPublish("", "rpc_queue", props, request.getBytes());

        return future.get(30, TimeUnit.SECONDS);
    }
}
```

**Ý tưởng:**
- Một reply queue duy nhất cho tất cả requests
- Dùng `correlationId` để match response với request
- ConcurrentHashMap để track pending requests

---

## Bẫy số 3: Producer không Singleton

Bạn có thể nghĩ: "OK, tôi đã fix channel leak và reply queue explosion rồi."

Nhưng còn một bẫy nữa.

### Vấn đề

Trong môi trường multi-threaded hoặc distributed (nhiều instance), nếu mỗi thread/instance tạo producer riêng:

```java
// Thread 1
RPCClient client1 = new RPCClient();  // Tạo reply queue 1

// Thread 2
RPCClient client2 = new RPCClient();  // Tạo reply queue 2

// Thread 3
RPCClient client3 = new RPCClient();  // Tạo reply queue 3

// ... 1000 threads = 1000 reply queues
```

Bạn lại rơi vào bẫy reply queue explosion!

### Giải pháp: Singleton Producer

Producer **BẮT BUỘC** phải là Singleton:

```java
public class RPCClient {
    private static volatile RPCClient instance;

    public static RPCClient getInstance() {
        if (instance == null) {
            synchronized (RPCClient.class) {
                if (instance == null) {
                    instance = new RPCClient();
                }
            }
        }
        return instance;
    }

    // Constructor private
    private RPCClient() {
        // ... setup connection, channel, reply queue
    }
}
```

**Double-checked locking** để đảm bảo thread-safe.

---

## Tổng kết các bẫy

| Bẫy | Triệu chứng | Giải pháp |
|-----|-------------|-----------|
| Channel Leak | "maximum channels limit" | Singleton Channel hoặc Channel Pool |
| Reply Queue Explosion | Memory tăng, Erlang processes tăng | Direct Reply-to hoặc Singleton Reply Queue |
| Non-singleton Producer | Nhiều reply queues bất thường | Singleton Producer pattern |

## Config chuẩn với Vert.x

Nếu dùng Vert.x RabbitMQ client, đây là config được khuyến nghị:

```java
RabbitMQOptions options = new RabbitMQOptions()
    .setUser(config.user)
    .setPassword(config.pass)
    .setHost(config.host)
    .setPort(config.port)
    .setAutomaticRecoveryEnabled(true)   // Tự động reconnect
    .setReconnectInterval(10000L)         // 10s giữa các lần retry
    .setReconnectAttempts(5)              // Retry 5 lần
    .setConnectionTimeout(7000)           // 7s connection timeout
    .setHandshakeTimeout(7000)            // 7s handshake timeout
    .setRequestedChannelMax(5)            // Giới hạn số channel
    .setNetworkRecoveryInterval(7000);    // 7s network recovery
```

**Lưu ý quan trọng:**
- `setRequestedChannelMax(5)` - giới hạn số channel để phát hiện leak sớm
- `setReconnectAttempts(5)` - không retry vô hạn, tránh connection storm

---

## Chúng tôi nghĩ đã học hết bài học

Sau khi fix tất cả những bẫy trên, team tôi tự tin hơn nhiều.

Channel được quản lý chặt chẽ. Reply queue dùng Singleton. Producer cũng Singleton.

Hệ thống chạy ổn định qua nhiều tháng.

Cho đến đêm 11 tháng 1 năm 2023.

![Storm Coming](https://images.unsplash.com/photo-1527482797697-8795b05a13fe?w=800)

## Teaser: Đêm 500 ngàn connections

8 giờ 09 phút tối. SOC gọi điện.

> "Anh ơi, RabbitMQ có vấn đề."

Nhìn vào dashboard:
- Message rate: **0** (về không)
- Connections: **500,000** (bình thường là 50,000)
- Erlang processes: tăng **2.5 lần**

Impact:
- **1.8 triệu transactions** bị lost
- **446,000 users** bị ảnh hưởng

Chuyện gì đã xảy ra? Và chúng tôi đã xử lý như thế nào?

Câu chuyện này, tôi sẽ kể trong phần cuối của series.

---

## Series "Bé Thỏ"

| Phần | Tiêu đề | Nội dung |
|------|---------|----------|
| [Phần 1](/vi/blog/be-tho-part-1) | Khi HTTP không còn đủ | RabbitMQ RPC, competing consumers |
| [Phần 2](/vi/blog/be-tho-part-2) | Những cái bẫy chết người | Channel Leak, Reply Queue Explosion (bạn đang ở đây) |
| [Phần 3](/vi/blog/be-tho-part-3) | Đêm 500 ngàn connections | Incident thực tế và bài học |
| [Phần 4](/vi/blog/be-tho-part-4) | Cuộc chiến không có kẻ thắng | Little's Law, accept uncertainty |

*Stay tuned!*