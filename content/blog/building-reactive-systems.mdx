---
title: Building Reactive Systems
title_vi: Xây dựng Reactive Systems - Từ Manifesto đến Thực tiễn
title_en: Building Reactive Systems - From Manifesto to Practice
excerpt_vi: Tìm hiểu The Reactive Manifesto với 4 trụ cột - Responsive, Resilient, Elastic, Message Driven. Các Resilience Patterns như Circuit Breaker, Bulkhead, Rate Limiter.
excerpt_en: Explore The Reactive Manifesto with 4 pillars - Responsive, Resilient, Elastic, Message Driven. Resilience Patterns like Circuit Breaker, Bulkhead, Rate Limiter.
date: 2024-01-20
tags:
  - Reactive
  - Architecture
  - Resilience
  - System Design
thumbnail: https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800
---

# Xây dựng Reactive Systems

## The Reactive Manifesto

Ngày **16 tháng 9 năm 2014**, Jonas Bonér cùng các đồng nghiệp công bố **The Reactive Manifesto** - tài liệu định nghĩa những đặc tính cốt lõi của một hệ thống Reactive.

![The Reactive Manifesto](https://images.unsplash.com/photo-1451187580459-43490279c0fa?w=800)

> Reactive Systems là những hệ thống có khả năng **đáp ứng cao**, **co giãn linh hoạt**, **chịu lỗi tốt**, và được xây dựng dựa trên **kiến trúc hướng thông điệp**.

---

## 4 Trụ cột của Reactive Systems

![Reactive Manifesto](https://images.unsplash.com/photo-1486406146926-c627a92ad1ab?w=800)

| Trụ cột | Ý nghĩa | Vai trò |
|---------|---------|---------|
| **RESPONSIVE** | Đáp ứng nhanh | Mục tiêu cuối cùng - UX tốt |
| **RESILIENT** | Khả năng phục hồi | Duy trì responsive khi có lỗi |
| **ELASTIC** | Co giãn linh hoạt | Duy trì responsive khi load thay đổi |
| **MESSAGE DRIVEN** | Hướng thông điệp | Nền tảng kỹ thuật cho tất cả |

**Mối quan hệ:** Message Driven → (Resilient + Elastic) → Responsive

---

## 1. Responsive (Đáp ứng nhanh)

Hệ thống phải **phản hồi kịp thời** nếu có thể. Tính đáp ứng là nền tảng của khả năng sử dụng.

![Responsive System](https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800)

### Đặc điểm của hệ thống Responsive:

| Đặc điểm | Mô tả |
|----------|-------|
| **Consistent response time** | Thời gian phản hồi nhất quán |
| **Simplified error handling** | Đơn giản hóa xử lý lỗi |
| **User confidence** | Xây dựng niềm tin cho người dùng |
| **Encourage interaction** | Khuyến khích tương tác và phát triển |

> **Key insight:** Responsive là kết quả của việc áp dụng tốt Resilient và Elastic.

---

## 2. Resilient (Khả năng phục hồi)

Hệ thống vẫn phải **responsive khi xảy ra failure**. Bất kỳ hệ thống không resilient sẽ unresponsive sau failure.

![Resilient System](https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800)

### Resilience đạt được thông qua:

| Kỹ thuật | Tiếng Việt | Mô tả |
|----------|------------|-------|
| **Replication** | Nhân bản | Nhân bản dữ liệu/service để failover |
| **Containment** | Cô lập | Cô lập failures, không lan truyền |
| **Isolation** | Tách biệt | Tách biệt components, giảm coupling |
| **Delegation** | Ủy quyền | Ủy quyền xử lý recovery cho component khác |

---

## 3. Elastic (Co giãn linh hoạt)

Hệ thống vẫn phải responsive dưới **workload thay đổi**. Có thể tăng hoặc giảm resources theo nhu cầu.

![Elastic System](https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800)

### Yêu cầu cho Elasticity:

| Yêu cầu | Giải thích |
|---------|------------|
| No central bottlenecks | Không có điểm nghẽn trung tâm |
| No contention points | Không có điểm tranh chấp |
| Shard/Replicate components | Khả năng phân mảnh và nhân bản |
| Distribute inputs | Phân phối input qua các components |

---

## 4. Message Driven (Hướng thông điệp)

Reactive Systems dựa vào **asynchronous message-passing** để thiết lập ranh giới giữa các components.

![Message Driven](https://images.unsplash.com/photo-1516321318423-f06f85e504b3?w=800)

### Lợi ích của Message-Driven:

- **Loose coupling** - Các component không phụ thuộc trực tiếp
- **Isolation** - Ranh giới rõ ràng giữa components
- **Location transparency** - Không cần biết vị trí vật lý
- **Error delegation** - Lỗi được truyền như messages
- **Back-pressure** - Kiểm soát flow khi overload

### Commands vs Events

| Đặc điểm | Commands | Events |
|----------|----------|--------|
| **Gửi đến** | Unicast (1 target) | Broadcast/Multicast |
| **Mục đích** | Yêu cầu action cụ thể | Thông báo điều đã xảy ra |
| **Response** | Expect response | Không expect response |
| **Ví dụ** | "Transfer $100 to User X" | "Transaction ABC completed" |

---

## Non-Blocking I/O với Netty

### Vấn đề với Blocking I/O

![Blocking IO Problem](https://images.unsplash.com/photo-1504639725590-34d0984388bd?w=800)

| Blocking I/O | Non-Blocking I/O |
|--------------|------------------|
| 1 thread = 1 connection | Few threads = thousands connections |
| Thread bị block khi chờ I/O | Không bị block |
| 10K connections = 10K threads | 10K connections = vài threads |
| High memory cost | Low memory cost |
| Context switching overhead | Minimal switching |

### Netty Architecture

**Kiến trúc Netty theo tầng:**

1. **Channels** - Đại diện cho các connections (conn1, conn2, conn3...)
2. **Selector** - Multiplexing - theo dõi nhiều channels cùng lúc
3. **Event Loop** - 1 Thread xử lý tất cả events

> **Key insight:** Với Netty, 1 Event Loop thread có thể quản lý hàng nghìn connections nhờ non-blocking I/O và multiplexing.

---

## Resilience Patterns

Khi xây dựng hệ thống thanh toán tại MoMo, chúng tôi áp dụng các patterns sau:

![Resilience Patterns](https://images.unsplash.com/photo-1563986768609-322da13575f3?w=800)

### 1. Retry Pattern

**Mục đích:** Thực hiện lại operation khi gặp transient failure.

| Bước | Trạng thái | Thời gian chờ |
|------|------------|---------------|
| 1 | Request → Fail | - |
| 2 | Wait | 1s |
| 3 | Retry → Fail | - |
| 4 | Wait (longer) | 2s |
| 5 | Retry → Fail | - |
| 6 | Wait (even longer) | 4s |
| 7 | Retry → **Success** | - |

> **Exponential Backoff**: Thời gian chờ tăng gấp đôi sau mỗi lần thất bại

**Best Practices:**
- Sử dụng **exponential backoff** (1s → 2s → 4s → 8s)
- Giới hạn số lần retry (max 3-5)
- Phân biệt lỗi có thể retry và không thể

### 2. Circuit Breaker Pattern

**Mục đích:** Ngăn chặn gọi liên tục đến service đang failed.

![Circuit Breaker](https://images.unsplash.com/photo-1555664424-778a1e5e1b48?w=800)

**Circuit Breaker State Flow:**

| Từ State | Điều kiện | Đến State |
|----------|-----------|-----------|
| **CLOSED** | Nhiều failures liên tiếp | **OPEN** |
| **OPEN** | Sau timeout | **HALF-OPEN** |
| **HALF-OPEN** | Test request thành công | **CLOSED** |
| **HALF-OPEN** | Test request thất bại | **OPEN** |

| State | Behavior |
|-------|----------|
| **Closed** | Hoạt động bình thường, đếm failures |
| **Open** | Reject requests ngay, không gọi downstream |
| **Half-Open** | Cho phép test requests để check recovery |

### 3. Rate Limiter Pattern

**Mục đích:** Kiểm soát số lượng requests trong một khoảng thời gian.

![Rate Limiter](https://images.unsplash.com/photo-1611974789855-9c2a0a7236a3?w=800)

**Các thuật toán:**

| Algorithm | Mô tả | Use case |
|-----------|-------|----------|
| Token Bucket | Mỗi request consume 1 token | API rate limiting |
| Leaky Bucket | Process với tốc độ cố định | Traffic shaping |
| Fixed Window | Đếm trong khoảng thời gian cố định | Simple counting |
| Sliding Window | Kết hợp ưu điểm các phương pháp | Smooth limiting |

### 4. Bulkhead Pattern

**Mục đích:** Cô lập các phần của system để failure không lan truyền.

![Bulkhead](https://images.unsplash.com/photo-1494412574643-ff11b0a5c1c3?w=800)

**Giống như khoang tàu thủy:**
- Các khoang (bulkhead) được ngăn cách
- Nước vào một khoang không làm chìm cả tàu

**Application với Bulkhead Pattern:**

| Thread Pool | Chức năng | Isolation |
|-------------|-----------|-----------|
| **Pool A** | Bank Integration | Riêng biệt |
| **Pool B** | Payment Processing | Riêng biệt |
| **Pool C** | User Service | Riêng biệt |

> Mỗi pool được cách ly hoàn toàn - nếu Bank Integration bị quá tải, Payment và User vẫn hoạt động bình thường.

### 5. Fallback Pattern

**Mục đích:** Cung cấp giá trị thay thế khi primary operation failed.

**Ví dụ:**
- Trả về cached data khi database không available
- Sử dụng default values khi external service down
- Redirect sang backup service

### 6. Timeout Pattern

**Mục đích:** Đặt giới hạn thời gian để tránh waiting vô thời hạn.

| Timeout | Vấn đề |
|---------|--------|
| Quá ngắn | False positives, request bị cancel sớm |
| Quá dài | Resources bị giữ lâu, cascade failures |
| Phù hợp | Dựa trên SLA và historical data |

---

## Kinh nghiệm thực tế tại MoMo

![MoMo Experience](https://images.unsplash.com/photo-1556742049-0cfed4f6a45d?w=800)

### Architecture áp dụng:

**1. Message-Driven Architecture:**
- Apache Kafka làm message broker
- Event Sourcing cho transaction history
- CQRS để tách read/write operations

**2. Resilience Patterns:**
- Circuit Breaker cho bank integrations (30+ banks)
- Retry với exponential backoff
- Bulkhead để isolate critical payment flows

**3. Non-Blocking I/O:**
- Vert.x cho core services
- Reactive streams với back-pressure
- Connection pooling với non-blocking drivers

### Kết quả đạt được:

| Metric | Trước | Sau |
|--------|-------|-----|
| Throughput | 10K TPS | 100K+ TPS |
| Latency P99 | 500ms | 50ms |
| Availability | 99.9% | 99.99% |
| Resource usage | High | Optimized |

---

## Key Takeaways

![Summary](https://images.unsplash.com/photo-1517245386807-bb43f82c33c4?w=800)

1. **Reactive không chỉ là technical choice** - Nó là architecture decision ảnh hưởng toàn bộ system design

2. **4 trụ cột phải áp dụng đồng bộ** - Thiếu một trong bốn sẽ làm giảm hiệu quả tổng thể

3. **Resilience patterns là bắt buộc** - Trong distributed systems, failure là bình thường, không phải exception

4. **Message-driven là nền tảng** - Cho phép loose coupling và location transparency

5. **Non-blocking I/O** là technical enabler cho high throughput

---

## Tài liệu tham khảo

- [The Reactive Manifesto](https://www.reactivemanifesto.org/)
- [Release It! - Michael Nygard](https://pragprog.com/titles/mnee2/release-it-second-edition/)
- [Designing Data-Intensive Applications](https://dataintensive.net/)
- [Vert.x Documentation](https://vertx.io/docs/)
